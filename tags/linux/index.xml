<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on Mark Mossberg&#39;s Blog</title>
    <link>https://vmresu.me/tags/linux/</link>
    <description>Recent content in linux on Mark Mossberg&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Nov 2019 11:18:14 -0500</lastBuildDate>
    
	<atom:link href="https://vmresu.me/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Notes on pedantic C&#43;&#43; compilation</title>
      <link>https://vmresu.me/posts/2019-11-28-cmake-libxml&#43;&#43;/</link>
      <pubDate>Thu, 28 Nov 2019 11:18:14 -0500</pubDate>
      
      <guid>https://vmresu.me/posts/2019-11-28-cmake-libxml&#43;&#43;/</guid>
      <description>Takeaways:
 Don&amp;rsquo;t assume it&amp;rsquo;s safe to use pre-built dependencies when compiling C++ programs. You might want to build from source, especially if you can&amp;rsquo;t determine how a pre-built object was compiled, or if you want to use a different C++ standard than was used to compile it.
 Ubuntu has public build logs which you can help you determine if you can use a pre-built object, or if you should compile from source.</description>
    </item>
    
    <item>
      <title>Struct stat notes</title>
      <link>https://vmresu.me/posts/2017-40-3-stat/</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vmresu.me/posts/2017-40-3-stat/</guid>
      <description>Note: i&amp;rsquo;m going to try a significantly more informal blogging style
 struct stat on Linux is pretty interesting
 the struct definition in the man page is not exactly accurate glibc explicitly pads the struct with unused members which is intersting. I guess to reserve space for expansion of fields  if you want to see the real definition, a trick you can use is writing a test program that uses a struct stat, and compiling with -E to stop after preprocessing then look in that output for the definition  you can look in the glibc sources and the linux sources and see that they actually have to make their struct definitions match!</description>
    </item>
    
    <item>
      <title>Let&#39;s understand: setjmp()/longjmp()</title>
      <link>https://vmresu.me/posts/2016-01-11-lets-understand-setjmp-slash-longjmp/</link>
      <pubDate>Tue, 09 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://vmresu.me/posts/2016-01-11-lets-understand-setjmp-slash-longjmp/</guid>
      <description>Pretty recently I learned about setjmp() and longjmp(). They&amp;rsquo;re a neat pair of libc functions which allow you to save your program&amp;rsquo;s current execution context and resume it at an arbitrary point in the future (with some caveats1). If you&amp;rsquo;re wondering why this is particularly useful, to quote the manpage, one of their main use cases is &amp;ldquo;&amp;hellip;for dealing with errors and interrupts encountered in a low-level subroutine of a program.</description>
    </item>
    
  </channel>
</rss>